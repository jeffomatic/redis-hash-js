// Generated by CoffeeScript 1.6.2
(function() {
  var RedisHash, events, inspect, puts, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  events = require('events');

  _ref = require('util'), puts = _ref.puts, inspect = _ref.inspect;

  RedisHash = (function(_super) {
    __extends(RedisHash, _super);

    RedisHash.isFalsy = function(v) {
      return (v === false) || !(v != null);
    };

    RedisHash.defaults = {
      emitErrs: true
    };

    function RedisHash(redis, key, opts) {
      var k, v, _ref1;

      this.redis = redis;
      this.key = key;
      this.opts = opts != null ? opts : {};
      _ref1 = this.constructor.defaults;
      for (k in _ref1) {
        v = _ref1[k];
        if (this.opts[k] == null) {
          this.opts[k] = v;
        }
      }
    }

    RedisHash.prototype._encode = function(trueOrFalse) {
      if (trueOrFalse === true) {
        return '1';
      } else if (trueOrFalse === false) {
        return '0';
      } else if (trueOrFalse != null) {
        return trueOrFalse.toString();
      } else {
        return trueOrFalse;
      }
    };

    RedisHash.prototype._booleanDecode = function(value) {
      switch (value) {
        case '1':
          return true;
        case '0':
          return false;
        default:
          return null;
      }
    };

    RedisHash.prototype._redisExec = function() {
      var args, command, done, _i, _ref1,
        _this = this;

      command = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), done = arguments[_i++];
      return (_ref1 = this.redis)[command].apply(_ref1, __slice.call(args).concat([function() {
        var err, results;

        err = arguments[0], results = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (err && _this.opts.emitErrs) {
          _this.emit('error', err);
        }
        return done.apply(null, [err].concat(__slice.call(results)));
      }]));
    };

    RedisHash.prototype.set = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      switch (args.length) {
        case 2:
          return this._hashSet.apply(this, args);
        case 3:
          return this._pairSet.apply(this, args);
        default:
          throw "Invalid number of arguments: " + args.length;
      }
    };

    RedisHash.prototype._hashSet = function(keysValues, done) {
      var hdelArgs, hmsetArgs, k, v,
        _this = this;

      hmsetArgs = [this.key];
      hdelArgs = [this.key];
      for (k in keysValues) {
        v = keysValues[k];
        if (v != null) {
          hmsetArgs.push(k);
          hmsetArgs.push(this._encode(v));
        } else {
          hdelArgs.push(k);
        }
      }
      if (hmsetArgs.length > 1 && hdelArgs.length > 1) {
        hmsetArgs.push(function(err, results) {
          if (err != null) {
            return done(err);
          } else {
            hdelArgs.push(done);
            return _this._redisExec.apply(_this, ['hdel'].concat(__slice.call(hdelArgs)));
          }
        });
        return this._redisExec.apply(this, ['hmset'].concat(__slice.call(hmsetArgs)));
      } else if (hmsetArgs.length > 1) {
        hmsetArgs.push(done);
        return this._redisExec.apply(this, ['hmset'].concat(__slice.call(hmsetArgs)));
      } else if (hdelArgs.length > 1) {
        hdelArgs.push(done);
        return this._redisExec.apply(this, ['hdel'].concat(__slice.call(hdelArgs)));
      } else {
        return process.nextTick(done);
      }
    };

    RedisHash.prototype._pairSet = function(k, v, done) {
      if (v != null) {
        return this._redisExec('hset', this.key, k, this._encode(v), done);
      } else {
        return this._redisExec('hdel', this.key, k, done);
      }
    };

    RedisHash.prototype.get = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      switch (args.length) {
        case 1:
          return this._redisExec('hgetall', this.key, args[0]);
        case 2:
          return this._redisExec('hget', this.key, args[0], args[1]);
        default:
          throw "Invalid number of arguments: " + args.length;
      }
    };

    RedisHash.prototype["delete"] = function(field, done) {
      return this._redisExec('hdel', this.key, field, done);
    };

    RedisHash.prototype.clear = function(done) {
      return this._redisExec('del', this.key, done);
    };

    RedisHash.prototype.setFlag = function(field, trueOrFalse, done) {
      return this._redisExec('hset', this.key, field, this._encode(trueOrFalse), done);
    };

    RedisHash.prototype.getFlag = function(field, done) {
      var _this = this;

      return this.get(field, function(err, result) {
        if (err) {
          return done(err);
        }
        return done(null, _this._booleanDecode(result));
      });
    };

    RedisHash.prototype.getFlags = function() {
      var done, fields, _i,
        _this = this;

      fields = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), done = arguments[_i++];
      if (Array.isArray(fields[0])) {
        fields = fields[0];
      }
      return this._redisExec.apply(this, ['hmget', this.key].concat(__slice.call(fields), [function(err, values) {
        var field, i, result, _j, _len;

        if (err) {
          return done(err);
        }
        result = {};
        for (i = _j = 0, _len = fields.length; _j < _len; i = ++_j) {
          field = fields[i];
          result[field] = _this._booleanDecode(values[i]);
        }
        return done(null, result);
      }]));
    };

    RedisHash.prototype.inc = function() {
      var args, delta, done, field;

      field = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      switch (args.length) {
        case 1:
          delta = 1;
          done = args[0];
          break;
        case 2:
          delta = args[0];
          done = args[1];
          break;
        default:
          throw "Invalid argument count: " + args.length;
      }
      return this._redisExec('hincrby', this.key, field, delta, done);
    };

    RedisHash.prototype.dec = function() {
      var args, delta, done, field;

      field = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      switch (args.length) {
        case 1:
          delta = -1;
          done = args[0];
          break;
        case 2:
          delta = -args[0];
          done = args[1];
          break;
        default:
          throw "Invalid argument count: " + args.length;
      }
      return this._redisExec('hincrby', this.key, field, delta, done);
    };

    return RedisHash;

  })(events.EventEmitter);

  module.exports = RedisHash;

}).call(this);
