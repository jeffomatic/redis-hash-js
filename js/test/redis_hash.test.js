// Generated by CoffeeScript 1.6.2
(function() {
  var RedisHash, assert, redisClient, sinon, testHelper,
    __slice = [].slice;

  assert = require('assert');

  sinon = require('sinon');

  testHelper = require('./test_helper');

  RedisHash = require('../lib/redis_hash');

  redisClient = testHelper.getRedisClient();

  describe('RedisHash', function() {
    beforeEach(function(done) {
      var _this = this;

      this.attribHash = new RedisHash(redisClient, 'testKey');
      this.attribHash.on('error', (this.errorSpy = sinon.spy()));
      return redisClient.flushdb(function(err, result) {
        if (err != null) {
          throw err;
        }
        return done();
      });
    });
    describe('#_redisExect', function() {
      it('should pass arbitrary arguments', function(done) {
        var _this = this;

        return this.attribHash._redisExec('hmset', 'testKey', 'a', 'apple', 'b', 'blueberry', function(err) {
          if (err) {
            throw err;
          }
          return redisClient.hgetall('testKey', function(err, results) {
            if (err) {
              throw err;
            }
            assert.deepEqual(results, {
              a: 'apple',
              b: 'blueberry'
            });
            return done();
          });
        });
      });
      return it('should emit errors', function(done) {
        var _this = this;

        return this.attribHash._redisExec('hdel', function(err) {
          assert(err);
          assert(_this.errorSpy.calledWith(err));
          return done();
        });
      });
    });
    describe('#set', function() {
      describe('key/value hash syntax', function() {
        beforeEach(function(done) {
          this.initialValues = {
            a: '1',
            b: '2',
            c: '3',
            d: '4'
          };
          return this.attribHash.set(this.initialValues, function(err, result) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        it('should persist a hash of values in Redis', function(done) {
          var _this = this;

          return redisClient.hgetall(this.attribHash.key, function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.deepEqual(result, _this.initialValues);
            return done();
          });
        });
        it('should not clobber existing values', function(done) {
          var newValues,
            _this = this;

          newValues = {
            e: '4',
            f: '5'
          };
          return this.attribHash.set(newValues, function(err, result) {
            if (err != null) {
              throw err;
            }
            return redisClient.hgetall(_this.attribHash.key, function(err, result) {
              var k, v, _ref;

              if (err != null) {
                throw err;
              }
              _ref = _this.initialValues;
              for (k in _ref) {
                v = _ref[k];
                assert.equal(result[k], v);
              }
              for (k in newValues) {
                v = newValues[k];
                assert.equal(result[k], v);
              }
              return done();
            });
          });
        });
        it('should encode boolean values', function(done) {
          var values,
            _this = this;

          values = {
            e: true,
            f: false
          };
          return this.attribHash.set(values, function(err, result) {
            if (err != null) {
              throw err;
            }
            return redisClient.hgetall(_this.attribHash.key, function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result.e, '1');
              assert.equal(result.f, '0');
              return done();
            });
          });
        });
        return it('should remove non-existent values', function(done) {
          var existentEncoded, k, v, values,
            _this = this;

          values = {
            a: false,
            b: 0,
            c: void 0,
            d: null
          };
          existentEncoded = {};
          for (k in values) {
            v = values[k];
            if (v != null) {
              existentEncoded[k] = this.attribHash._encode(v);
            }
          }
          return this.attribHash.set(values, function(err, result) {
            if (err != null) {
              throw err;
            }
            return redisClient.hgetall(_this.attribHash.key, function(err, result) {
              assert.deepEqual(result, existentEncoded);
              return done();
            });
          });
        });
      });
      return describe('key/value pair syntax', function() {
        beforeEach(function(done) {
          var _this = this;

          return this.attribHash.set('foo', 'bar', function(err, results) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        it("should persist values into Redis", function(done) {
          var _this = this;

          return redisClient.hget(this.attribHash.key, 'foo', function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, 'bar');
            return done();
          });
        });
        it('should encode boolean true values', function(done) {
          var _this = this;

          return this.attribHash.set('foo', true, function(err, result) {
            if (err != null) {
              throw err;
            }
            return redisClient.hget(_this.attribHash.key, 'foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, '1');
              return done();
            });
          });
        });
        it('should encode boolean false values', function(done) {
          var _this = this;

          return this.attribHash.set('foo', false, function(err, result) {
            if (err != null) {
              throw err;
            }
            return redisClient.hget(_this.attribHash.key, 'foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, '0');
              return done();
            });
          });
        });
        it('should remove null values', function(done) {
          var _this = this;

          return this.attribHash.set('foo', null, function(err, result) {
            if (err != null) {
              throw err;
            }
            return redisClient.hexists(_this.attribHash.key, 'foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, 0);
              return done();
            });
          });
        });
        return it('should remove undefined values', function(done) {
          var _this = this;

          return this.attribHash.set('foo', void 0, function(err, result) {
            if (err != null) {
              throw err;
            }
            return redisClient.hexists(_this.attribHash.key, 'foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, 0);
              return done();
            });
          });
        });
      });
    });
    describe('#get', function() {
      describe('get-everything syntax', function() {
        beforeEach(function(done) {
          var _this = this;

          this.attribs = {
            a: 'first',
            b: 'second',
            c: 'third'
          };
          return this.attribHash.set(this.attribs, function(err, result) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        it('should return the entire hash of values', function(done) {
          var _this = this;

          return this.attribHash.get(function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.deepEqual(result, _this.attribs);
            return done();
          });
        });
        return it('should return null if the hash is empty', function(done) {
          var _this = this;

          return redisClient.hdel.apply(redisClient, [this.attribHash.key].concat(__slice.call(Object.keys(this.attribs)), [function(err, result) {
            if (err != null) {
              throw err;
            }
            return _this.attribHash.get(function(err, result) {
              if (err != null) {
                throw err;
              }
              assert(result == null);
              return done();
            });
          }]));
        });
      });
      return describe('get-value syntax', function() {
        beforeEach(function(done) {
          return this.attribHash.set('foo', 'bar', function(err, result) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        it('should correctly return the name value', function(done) {
          var _this = this;

          return this.attribHash.get('foo', function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, 'bar');
            return done();
          });
        });
        return it("should return null for values that don't exist", function(done) {
          return this.attribHash.get('foobar', function(err, result) {
            if (err != null) {
              throw err;
            }
            assert(result == null);
            return done();
          });
        });
      });
    });
    describe('#delete', function() {
      beforeEach(function(done) {
        return this.attribHash.set('foo', 'bar', function(err, result) {
          if (err != null) {
            throw err;
          }
          return done();
        });
      });
      return it('should delete individual values from the hash', function(done) {
        var _this = this;

        return this.attribHash["delete"]('foo', function(err, result) {
          if (err != null) {
            throw err;
          }
          return redisClient.hexists(_this.attribHash.key, 'foo', function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, 0);
            return done();
          });
        });
      });
    });
    describe('#clear', function() {
      beforeEach(function(done) {
        var _this = this;

        return this.attribHash.set({
          a: 'first',
          b: 'second'
        }, function(err, result) {
          if (err != null) {
            throw err;
          }
          return done();
        });
      });
      return it('should remove the hash from Redis', function(done) {
        var _this = this;

        return this.attribHash.clear(function(err, result) {
          if (err != null) {
            throw err;
          }
          return redisClient.exists(_this.attribHash.key, function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, 0);
            return done();
          });
        });
      });
    });
    describe('flag attributes', function() {
      describe('#getFlag', function() {
        beforeEach(function(done) {
          var _this = this;

          return this.attribHash.set('foo', true, function(err, result) {
            if (err != null) {
              throw err;
            }
            return _this.attribHash.set('bar', false, function(err, result) {
              if (err != null) {
                throw err;
              }
              return done();
            });
          });
        });
        it('should return true for values set with #set(true)', function(done) {
          return this.attribHash.getFlag('foo', function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, true);
            return done();
          });
        });
        it('should return false for values set with #set(false)', function(done) {
          return this.attribHash.getFlag('bar', function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, false);
            return done();
          });
        });
        return it('should return null for non-existent values', function(done) {
          return this.attribHash.getFlag('foobar', function(err, result) {
            if (err != null) {
              throw err;
            }
            assert(result == null);
            return done();
          });
        });
      });
      return describe('#getFlags', function() {
        beforeEach(function(done) {
          var _this = this;

          return this.attribHash.set({
            a: '1',
            b: '0',
            c: 'not a boolean'
          }, function(err) {
            if (err) {
              throw err;
            }
            return done();
          });
        });
        it('should return values as an object', function(done) {
          var _this = this;

          return this.attribHash.getFlags('a', 'b', function(err, results) {
            if (err) {
              throw err;
            }
            assert(results.a);
            assert((results.b != null) && !results.b);
            return done();
          });
        });
        it('should accept an array argument', function(done) {
          var _this = this;

          return this.attribHash.getFlags(['a', 'b'], function(err, results) {
            if (err) {
              throw err;
            }
            assert(results.a);
            assert((results.b != null) && !results.b);
            return done();
          });
        });
        return it('should return null for non-boolean encoded values', function(done) {
          var _this = this;

          return this.attribHash.getFlags('a', 'b', 'c', function(err, results) {
            if (err) {
              throw err;
            }
            assert(results.a);
            assert((results.b != null) && !results.b);
            assert(results.c == null);
            return done();
          });
        });
      });
    });
    return describe('counter attributes', function() {
      describe('#inc', function() {
        beforeEach(function(done) {
          this.attribs = {
            foo: 1,
            bar: 'hey hey hey'
          };
          return this.attribHash.set(this.attribs, function(err, result) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        describe("default increment value", function() {
          it('should return and persist the incremented value', function(done) {
            var _this = this;

            return this.attribHash.inc('foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, _this.attribs.foo + 1);
              return _this.attribHash.get('foo', function(err, result) {
                if (err != null) {
                  throw err;
                }
                assert.equal(result, (_this.attribs.foo + 1).toString());
                return done();
              });
            });
          });
          it('should treat non-existent values as zero', function(done) {
            var _this = this;

            return this.attribHash.inc('foobar', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, 1);
              return _this.attribHash.get('foobar', function(err, result) {
                if (err != null) {
                  throw err;
                }
                assert.equal(result, '1');
                return done();
              });
            });
          });
          return it('should return errors on non-numeric values', function(done) {
            var _this = this;

            return this.attribHash.inc('bar', function(err, result) {
              assert(_this.errorSpy.calledWith(err));
              assert(err.message.match(/ERR hash value is not an integer/));
              return done();
            });
          });
        });
        it('should accept arbitrary positive increments', function(done) {
          var _this = this;

          return this.attribHash.inc('foo', 5, function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, _this.attribs.foo + 5);
            return _this.attribHash.get('foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, (_this.attribs.foo + 5).toString());
              return done();
            });
          });
        });
        return it('should accept arbitrary negative increments', function(done) {
          var _this = this;

          return this.attribHash.inc('foo', -5, function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, _this.attribs.foo - 5);
            return _this.attribHash.get('foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, (_this.attribs.foo - 5).toString());
              return done();
            });
          });
        });
      });
      return describe('#dec', function() {
        beforeEach(function(done) {
          this.attribs = {
            foo: 1,
            bar: 'hey hey hey'
          };
          return this.attribHash.set(this.attribs, function(err, result) {
            if (err != null) {
              throw err;
            }
            return done();
          });
        });
        describe("default decrement value", function() {
          it('should return and persist the decremented value', function(done) {
            var _this = this;

            return this.attribHash.dec('foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, _this.attribs.foo - 1);
              return _this.attribHash.get('foo', function(err, result) {
                if (err != null) {
                  throw err;
                }
                assert.equal(result, (_this.attribs.foo - 1).toString());
                return done();
              });
            });
          });
          it('should treat non-existent values as zero', function(done) {
            var _this = this;

            return this.attribHash.dec('foobar', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, -1);
              return _this.attribHash.get('foobar', function(err, result) {
                if (err != null) {
                  throw err;
                }
                assert.equal(result, '-1');
                return done();
              });
            });
          });
          return it('should return errors on non-numeric values', function(done) {
            var _this = this;

            return this.attribHash.dec('bar', function(err, result) {
              assert(_this.errorSpy.calledWith(err));
              assert(err.message.match(/ERR hash value is not an integer/));
              return done();
            });
          });
        });
        it('should accept arbitrary positive decrements', function(done) {
          var _this = this;

          return this.attribHash.dec('foo', 5, function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, _this.attribs.foo - 5);
            return _this.attribHash.get('foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, (_this.attribs.foo - 5).toString());
              return done();
            });
          });
        });
        return it('should accept arbitrary negative decrements', function(done) {
          var _this = this;

          return this.attribHash.dec('foo', -5, function(err, result) {
            if (err != null) {
              throw err;
            }
            assert.equal(result, _this.attribs.foo + 5);
            return _this.attribHash.get('foo', function(err, result) {
              if (err != null) {
                throw err;
              }
              assert.equal(result, (_this.attribs.foo + 5).toString());
              return done();
            });
          });
        });
      });
    });
  });

}).call(this);
